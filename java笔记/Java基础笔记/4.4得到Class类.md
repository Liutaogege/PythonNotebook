# Class类

对象照镜子后可以得到的信息，某个类的属性、方法和构造器，某个类到底实现了哪些接口。对于每个类而言，jre都为其保留一个不变的Class类型的对象。一个Class对象包含了某个特定的结构（class/interface/enum/annotation/primitive type/void/[])的有关信息

* Class本身也是一个类
* Class对象只能由系统建立对象
* 一个加载的类在jvm中只会有一个Class实例
* 一个Class对象对应的是一个加载到JVM中的一个class文件
* 每个类的实例都会记得自己是由哪个Class实例所生成
* 通过Class可以完整地得到一个类中的所有被加载的结构
* Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象



# Class类的常用方法

| 方法名                               | 功能说明                                                    |
| ------------------------------------ | ----------------------------------------------------------- |
| `static ClassforName(String name)`   | 返回指定类名name的class对象                                 |
| getName()                            | 返回此Class对象所表示的实体（类，接口，数组类或void）的名称 |
| Class getSuperClass()                | 返回当前Class对象的父类的Class对象                          |
| Class[] getinterfaces()              | 获取当前Class对象的接口                                     |
| ClassLoader getClassLoader()         | 返回该类的加载器                                            |
| Constructor[] getConstructors()      | 返回一个包含某些Constructor对象的数组                       |
| Method getMothed(String name, Class) | 返回一个Method对象，此对象的类型为paramType                 |
| Field[] getDeclaredFields()          | 返回Field对象的一个数组                                     |
| Object newInstance()                 | 调用缺省构造函数，返回class对象的一个实例                   |



# 获取Class类的实例

* 若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高。
  * `Class clazz = Person.class`
* 已知某个类的实例，调用该实例的getClass()方法获取Class对象
  * `Class clazz = person.getClass();`
* 已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出ClassNotFoundException
  * `Class clazz = Class.forName("demo1 Student");`
* 内置基本数据类型可以直接用  类名.Type
* 还可以用ClassLoader