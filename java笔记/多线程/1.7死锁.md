# 死锁

多个线程各自占有一些共享资源，并且互相等待其他线程占有的资源才能运行，而导致两个或者多个线程都在等待对方释放资源，进而都停止执行的请求，某一个同步块同时拥有==两个以上对象的锁==时，就可能会发生死锁问题。

synchronized块是自动释放锁的。举个例子：加入t1线程占有了A资源，t2占有了B资源，t1在没有释放A资源的情况下想去占有B资源，t2呢在没有释放B资源的情况下想占有A资源，导致就卡死了。

```java
package dead_lock;

import jdk.internal.org.objectweb.asm.util.TraceAnnotationVisitor;

public class DeadLockTest{
    public static void main(String[] args) {
        MakeUp g1 = new MakeUp(0, "g1");
        MakeUp g2 = new MakeUp(1, "g2");

        new Thread(g1).start();
        new Thread(g2).start();
    }

}

class LipStick {

}

class Mirror {

}

class MakeUp implements Runnable {
    // 这是资源
    static LipStick lipStick = new LipStick();
    static Mirror mirror = new Mirror();

    int choice;
    String girlName;

    public void run() {
        // 化妆
        try {
            makingUp();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public MakeUp(int choice, String girlName) {
        this.choice = choice;
        this.girlName = girlName;
    }

    public void makingUp() throws InterruptedException{
        if (choice == 0) {
            // 来分析一下为什么产生死锁：
            /*
            * 第一个线程占用了lipStick这个资源，在没有释放它的情况下（出了synchronized认为是释放资源）紧接着又申请了另外一个资源
            * 同样的道理，第二个资源也是这样，并且未释放的都是彼此想要申请的资源，所以造成死锁
            * 想要解决，就是在申请第二个资源的时候先把第一个占用的资源释放出来
            * */
            synchronized(lipStick) {
                System.out.println(this.girlName + "在用口红");
                Thread.sleep(1000);
                // 下面这个代码在这会产生死锁
//                synchronized (mirror) {
//                    System.out.println(this.girlName + "想要使用镜子");
//                }
            }
            // 放在这里就不会了，因为已经释放了第一个资源
            synchronized (mirror) {
                System.out.println(this.girlName + "想要使用镜子");
            }
        }else {
            synchronized (mirror) {
                System.out.println(this.girlName + "在用镜子");
                Thread.sleep(2000);
                // 道理同上，不过只要上面先释放了资源，没人占用资源，这代码放在这里也是可以的
                synchronized (lipStick) {
                    System.out.println(this.girlName + "想要使用口红");
                }
            }
        }
    }
}
```

