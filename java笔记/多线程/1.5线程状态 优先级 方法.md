# 线程状态

![image-20211019221942600](/Users/jared/Library/Application Support/typora-user-images/image-20211019221942600.png)



# 线程状态观测

**Thread.State**
线程状态有多种，如下：

1. NEW:

   尚未启动的线程处于此状态

2. RUNNABLE

   在java虚拟机汇总执行的线程处于此状态

3. BLOCKED

   被阻塞等待监视器锁定的线程处于此状态

4. WAITING

   正在等待另一个线程执行特定动作的线程处于此状态

5. TIMED_WAITING

   正在等待另一个线程执行动作达到指定等待时间的线程处于此状态

6. TERMINATED

   已退出的线程处于此状态

这些状态时不反映任何操作系统线程状态的虚拟机状态。

```java
package join;

public class JoinTest implements Runnable{
    public void run() {
        for (int i = 0; i < 5; i++) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        JoinTest t = new JoinTest();
        Thread thread = new Thread(t);

        Thread.State state = thread.getState();
        System.out.println("未启动的线程状态：" + state);

        thread.start();
        state = thread.getState();
        System.out.println("启动以后的线程状态: " + state);

        while (state != Thread.State.TERMINATED) { // 如果线程不终止
            Thread.sleep(100);
            state = thread.getState(); // 更新状态
            System.out.println("状态 " + state);
        }
    }
}

```





# 线程方法

* setPriority(int newPriority) 更改线程的优先级
* static void sleep(long millis) 在指定的毫秒数内让当前正在执行的线程休眠
* void join()     等待该线程终止
* static void yield()  暂停当前正在执行的线程对象，并执行其他线程
* void interrupt()   中断线程，尽量别用
* Boolean isAlive()   测试线程是否处于活动状态
  * 不推荐让线程强制停下来，建议使用一个标志位进行终止变量，当flag=false，则终止线程运行。



# 线程优先级

* java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行
* 线程的优先级用数字1-10表示
  * Thread.MIN_PRIORITY = 1;
  * Thread.MAX_PRIORITY = 10;
  * Thread.NORM_PRIORITY = 5;
* 下列方法获取或改变优先级
  * getPriority() , setPriority(int xxx)

优先级低只是意味着获得调度的概率低，并不是优先级低就不会被调用了，这都是看CPU的调度。

```java
package priority;

public class PriorityTest implements Runnable{

    public void run() {
        // 获取优先级
        System.out.println(Thread.currentThread().getName() + "在跑" + Thread.currentThread().getPriority());
    }

    public static void main(String[] args) {
        PriorityTest priorityTest = new PriorityTest();

        Thread t1 = new Thread(priorityTest, "t1");
        Thread t2 = new Thread(priorityTest, "t2");
        Thread t3 = new Thread(priorityTest, "t3");
        Thread t4 = new Thread(priorityTest, "t4");
        Thread t5 = new Thread(priorityTest, "t5");

        t5.setPriority(Thread.MAX_PRIORITY);
        t5.start();
        t1.start();

        // 设置优先级
        t2.setPriority(6);
        t2.start();

        t3.start();
        t4.setPriority(9);
        t4.start();
    }
}

```

