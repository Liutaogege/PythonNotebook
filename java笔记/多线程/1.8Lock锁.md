# Lock锁

感觉和python中的lock锁是一样的

synchronized这个锁是自动释放的，但是lock锁是需要手动进行释放

* Lock锁是显式定义同步锁对象来实现同步
* java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具，锁提供了对共享资源的独自访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应该先获得Lock对象
* ReentrantLock类实现了Lock，拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁。

书写格式：

```java
class LockingTest implements Runnable{
    // 定义锁
    private final ReentrantLock lock = new ReentrantLock();


    public void fun() {
        lock.lock();
        try{
            // 代码执行
        } finally {
           // 代码有异常，要释放锁
           lock.unlock();
        }


    }

}
```



==synchronized和Lock的对比==

* Lock是显式锁，需要手动开启和关闭，synchronized是隐式锁，出了作用域自动释放
* Lock只有代码块锁，synchronized有代码块锁和方法锁
* 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好，并且具有更好的扩展性（提供更多的子类）
* 优先使用顺序
  * Lock>同步代码块（已经进入了方法体，并且分配了相应的资源）>同步方法（在方法体之外）