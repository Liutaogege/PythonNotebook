# 静态代理模式

说白了就像python的装饰器一样，真实对象被代理对象封装，代理对象做了很多额外的事情

特点：

* 真实对象和代理对象都要实现同一个接口
* 代理对象代理真实角色

好处：

* 代理对象在不改变真实对象的情况下可以对真实对象进行封装
* 真实对象专注于做自己的事情

==所以可知线程的底层实现原理就是静态代理模式。==

```java
//将Runnable接口实现的线程与下面的代码进行对比
new Thread(()-> System.out.println("我爱你")).start();
new WeddingCommpany(new You()).HappyMarry();
```



```java
package static_proxy;

public class StaticProxy {
    public static void main(String[] args) {
        You you = new You();

        WeddingCompany weddingCompany = new WeddingCompany(you);
        weddingCompany.HappyMarry();

    }
}


interface MarryService {
    void HappyMarry();
}

// 代理对象和真实对象都要实现同一个接口
class You implements MarryService {
    public void HappyMarry() {
        System.out.println("你结婚了，你狠开心");
    }
}

class WeddingCompany implements MarryService {
    private MarryService target;

    public WeddingCompany(MarryService target) {
        this.target = target;
    }

    // 代理对象实现的接口方法，对真实对象的方法进行了封装
    public void HappyMarry() {
        BeforeMarry();
        // 这里执行的是真实对象的方法
        this.target.HappyMarry();
        AfterMarry();
    }

    public void BeforeMarry() {
        System.out.println("婚前准备，好麻烦");
    }

    public void AfterMarry() {
        System.out.println("婚后蜜月，好开心！");
    }
}
```

