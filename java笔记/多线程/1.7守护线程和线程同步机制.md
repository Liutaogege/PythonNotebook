# 守护线程

* 线程分为==用户线程和守护线程==
* 虚拟机必须确保用户线程执行完毕
* 虚拟机不用等待守护线程执行完毕

定义：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。

```java
package daemon;

public class DaemonTest implements Runnable{

    public void run() {
        while(true) {
            System.out.println(Thread.currentThread().getName() + "在跑");
        }

    }

    public static void main(String[] args) throws InterruptedException {
        DaemonTest daemonTest = new DaemonTest();

        Thread thread1 = new Thread(daemonTest, "t1");
        thread1.setDaemon(true);  // setDaemon(),默认为false，程序不会管守护线程

        thread1.start();

        for (int i = 0; i < 10; i++) {
            System.out.println("主线程在跑" + i);
            Thread.sleep(100);
        }
    }
}
//上述程序在跑了一段时间后会停下来，不管thread1是否执行完，因为它是守护线程
```



# 线程同步

* 由于同一进程的多个线程共线一块存储空间，为了保证数据在方法中被访问时的正确性，在访问时加入==锁机制synchronized==，当一个线程获得对象的排它锁，独占资源，其他线程必须等待，使用后释放锁即可，存在以下问题：
  * 一个线程持有锁会导致其他所有需要此锁的线程挂起
  * 在多线程竞争下，加锁，释放锁会导致比较多的上下文切换和调度延时，引起性能问题
  * 如果一个优先级高的线程等待一个优先级低的线程释放锁，会导致优先级倒置（优先级高的执行只要几秒钟，优先级低的却需要几分钟），引起性能问题



## 同步方法

* 由于我们可以通过private关键字来保证数据对象只能被方法访问，所以只需要针对方法提出一套机制，这套机制就是synchronized关键字，它包括两种用法：**synchronized方法和synchronized块**
  * `同步方法： public synchronized void method(int args) {}`
* synchronized方法控制对”对象“的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞，方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才能获得这个锁，继续执行。
  * 缺陷：若将一个大的方法申明为synchronized将会影响效率

```java
package lock_buy_ticket;

public class BuyTicket implements Runnable{
    private int ticket_nums = 10;

    public void run() {
        while (true) {
            if (this.ticket_nums <= 0) break;
            buy();

            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public synchronized void buy() {
        System.out.println(Thread.currentThread().getName() + "买了第" + ticket_nums-- + "张票");
    }

    public static void main(String[] args) {
        BuyTicket buyTicket = new BuyTicket();
        Thread t1 = new Thread(buyTicket, "我");
        Thread t2 = new Thread(buyTicket, "刘婷");
        Thread t3 = new Thread(buyTicket, "黄牛");

        t1.start();
        t2.start();
        t3.start();

    }
}



```





# 同步块

* 同步块：synchronized(Obj) {}，锁住的只能是对象
* Obj称之为同步监视器
  * Obj可以是任何对象，但是推荐使用共享资源作为同步监视器
  * 同步方法中无需指定同步监视器，因为同步方法的同步监视器就是this，就是这个对象本身，或者是class
* 同步监视器的执行过程
  1. 第一个线程访问，锁定同步监视器，执行其中代码
  2. 第二个线程访问，发现同步监视器被锁定，无法访问
  3. 第一个线程访问完毕，解锁同步监视器
  4. 第二个线程访问，发现同步监视器没有锁，然后锁定并访问

```java
package AddList;

import java.util.ArrayList;
import java.util.List;

public class AddList {
    public static void main(String[] args) {
        List<String> list = new ArrayList<String>();
        for (int i = 0; i < 10000; i++) {
            new Thread(()-> {
              // 锁住list对象
                synchronized (list) {
                    list.add("1");
                }
            }).start();
        }

//        try {
//            Thread.sleep(100);
//        } catch (InterruptedException e) {
//            e.printStackTrace();
//        }

        System.out.println(list.size());
    }
}

```



线程安全的list是：CopyOnWriteArrayList