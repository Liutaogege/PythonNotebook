# 链表

是一种特殊的结构体，他的外部结构是一串存放数据的对象，它的内部结构包含两部分，即存放数据和指针。

**链表是一种动态的数据结构，它所需要的内存空间无法预先确定，取决于实际的应用情况。所以需要进行内存管理。**

C语言提供了一些内存管理函数，运用这些内存管理函数可以按需动态地分配内存空间，用于存放结点的数据，用结点的指针把各个结点链接起来构成一个链表，当链表或者某个结点不用时可以空间回收待利用。

## 1.内存管理系统函数
C语言中有多种内存管理系统函数，介绍三种与链表有关的。它们都包含在stdlib.h文件中。引入`#include <stdlib.h>`

**(1)malloc()函数**

调用方式为:`(类型说明符*) malloc(size)`

它的功能是在内存的动态存储区分配一块大小为size字节的连续空间，若分配成功，则返回所分配的内存单元的首地址，若不成功，则返回NULL。

这个函数返回的值必须是一个指针变量，而且使用强制类型转换的方式将返回值转换成指针变量所指向的类型，及“类型说明符*”

```c
int *p1;
float *p2;
// 申请空间大小为一个整型大小的空间，并将p1指向该空间的首地址
p1=(int *) malloc(sizeof(int));
p2=(float *) malloc(sizeof(float));

if (p1!=NULL && p2!=NULL) {
  printf("分配成功！");
}
```

**（2）calloc()函数**

格式是：`(类型说明符*) calloc(items, size)`

calloc的功能是在内存的动态存储区分配items块大小为size字节的连续空间，若分配成功，则返回所分配的内存单元的首地址，若不成功，则返回NULL。它的返回结果也是一个指针变量，需要使用强制类型转换将结果转变为指定类型的指针。

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

struct student {
    int num;
    char name[20];
    struct student *p;
};

float *p;
int m=3;
p=(float *) calloc(3, sizeof(float));
if (p!=NULL) {
  printf("空间分配成功");
}
```

**（3）free(p)函数**
free的功能是释放指针p所指向的内存区，其中参数p必须是先前调用malloc函数或者calloc函数时返回的指针。

```c
int main() {
  struct student *stu;
  stu=(struct student *) malloc(sizeof(struct student));
  if (stu!=NULL) {
    stu->num=1;
    printf("%d\n", stu->num);
    free(stu);
    printf("%d", stu->num);
  }
  return 0;
}

struct student *stu;
stu=(struct student *) malloc(sizeof(struct student));
if (stu!=NULL) {
  stu->num=1;
  printf("%d\n", stu->num);
  free(stu);
  printf("%d", stu->num);
}
```



**memset(void *s, int c, unsigned long n)函数**

将指针变量 s 所指向的前 n 字节的内存单元用一个“整数” c 替换,注意 c 是 int 型。s 是 void* 型的指针变量，所以它可以为任何类型的数据进行初始化。



## 示例：建立一个单链表

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

struct student {
    int num;
    char name[20];
    struct student *p;
};

int main() {
    struct student *head,*end,*next;
    int index;
    char sname[20];
    
    head=(struct student *) malloc(sizeof(struct student));
    if (head==NULL) {
        printf("空间分配失败");
    }
    else {
        printf("请输入第一个结点的数据：\n");
        scanf("%d %s", &index, sname);
        head->num=index;
        strcpy(head->name, sname);
        // 第一个结点的下一个节点为空，并且他也是end结点
        end=head;
        head->p=NULL;
        for (int i=0; i<4; i++) {
            next = (struct student *) malloc(sizeof(struct student));
            scanf("%d %s", &index, sname);
            next->num=index;
            strcpy(next->name, sname);
            // 每插入一个新结点就是尾结点
            next->p=NULL;
            // 原来的结点要指向该结点，而原来的结点就是原来的尾结点
            end->p=next;
            // 而新的尾结点就是当前的next结点
            end=next;
        }
    }
    printf("%s", head->name);
    printf("%s", head->p->name);
    
    // 对链表循环输出
    struct student *ps;
    ps=head;
    while (ps->p!=NULL) {
        printf("%d %s\n", ps->num, ps->name);
        ps=ps->p;
    }
    
    return 0;
}
```

