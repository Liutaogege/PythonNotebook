python有很多种设计模式，在《设计模式》一书中，作者归纳出23中设计模式，并将它们分为三大类：创建型，结构型，行为型。

创建型：将对象的创建和对象的分开使用，对对象的创建进行研究

结构型：主要探讨研究对象的组成以及对象之间的依赖关系

行为型模式：设计对象的行为，提高对象之间的协作效率

# 一、创建型之单例模式

保证一个类仅有一个实例。

应用场景：比如某些配置文件，计数器等等。

```python
class NoValue(object):    
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            ......
            cls._instance = object.__new__(cls)

        return cls._instance


class EndOfOctets(base.AbstractSimpleAsn1Item):
    _instance = None

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:
            cls._instance = object.__new__(cls, *args, **kwargs)

        return cls._instance
```

### 实现方式有哪些

#### 方式一：使用模块

python的模块就是天然的单例模式，因为模块在第一次导入时，会生成.pyc文件，当二次导入，就会直接加载.pyc文件而不会再执行模块代码。所以，只需要把相关的属性和函数定义在一个模块中，构建一个对象，需要用的时候再导入这个对象即可。

比如：

#### 方式二：使用装饰器

#### 方式三：使用魔法函数\_\__new_\__

​    上次昆明企业微信就出现了实例化对象时重复请求生成session，导致bug，就是采用单例模式解决的。

<img src="/Users/jared/Library/Application Support/typora-user-images/image-20211125210011355.png" alt="image-20211125210011355" style="zoom:50%;" />

#### 方式四：使用元类metaclass

# 二、结构型之适配器模式

**又称为wrapper模式，将一个类的接口转换成为客户希望的另外一个接口，可以使原本由于接口不兼容而不能一起工作的那些类可以一起工作。**

精彩的比喻：笔记本使用的是12V, 而外部电源有100-220v 不同的, 此时需要一个电源适配器, 对电源进行适配

应用场景：主要应用于希望复用一些现存的接口，但是接口又与复用环境要求不一致的情况且对现存的接口不能进行修改。实际例子就比如第三方登录场景：

```
比如一个支付系统，有三种不同的支付方式，微信支付、支付宝支付、网银支付，这三种支付的实现方法都不一样，那么我们可以用适配器模式，让他们对外具有统一的方法，这样，我们在调用的时候就非常的方便。
```

```
再比如老系统的登录接口，随着业务的发展和社会的进步，单纯地依赖用户名密码登录显然不能满足用户需求了。目前大部分系统都已经支持多种登录方式，如QQ 登录、微信登录、手机登录、微博登录等等，同时保留用户名密码的登录方式。虽然登录形式丰富了，但是登录后的处理逻辑可以不必改，比如将登录状态保存到session
```

### 实现方式有哪些

主要有两种：

#### 一、类适配模式（继承）

<img src="/Users/jared/Library/Application Support/typora-user-images/image-20211125212638593.png" alt="image-20211125212638593" style="zoom:50%;" />    

#### 二、对象适配模式

<img src="/Users/jared/Library/Application Support/typora-user-images/image-20211125212728130.png" alt="image-20211125212728130" style="zoom:50%;" />

# 三、行为型之观察者模式

 实例：odoo中的watchdog

```
watchdog介绍：
监控指定目录/文件的变化，如添加删除文件或目录、修改文件内容、重命名文件或目录等，每种变化都会产生一个事件，且有一个特定的事件类与之对应，然后再通过事件处理类来处理对应的事件，怎么样处理事件完全可以自定义，只需继承事件处理类的基类并重写对应实例方法
主要有三个角色：observer，event_handler，被监控的文件夹
```

```
FSEventsEmitter:事件派发器,emitter_class
threading.RLock: 可重入锁，也称递归锁,线程锁的一种
```
