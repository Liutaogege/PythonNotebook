# 地址映射和替换算法

## 一、Cache-主存的地址映射

有三种映射方式：

1. 直接映射
   
   前面说过主存的被划分为m块，cache被划分为c块，且m>>c，那么就可以将主存划分为m/c个组，则每个组就相当于是一个缓存大小。每组就和缓存一一对应。但是这种不好的是缓存的利用率会有点低，考虑一种情况，假设CPU已经把第一组的字块0给占用了，突然需要使用第二组的字块0，由于已经被占领，那么就会把第一组的字块0缓存给擦去装入第二组的字块0
   
   ![](/Users/jared/Library/Application%20Support/marktext/images/2021-12-11-13-26-28-image.png)

2. 全相联映射
   
   和上面一种一一对应不同，字块0可以存放在任何位置，但是查找起来比较费时
   
   ![](/Users/jared/Library/Application%20Support/marktext/images/2021-12-11-13-27-57-image.png)

3. 组相联映射
   
   把缓存也分成了多个组，每个组有两块字块，结合了上面两种方式
   
   ![](/Users/jared/Library/Application%20Support/marktext/images/2021-12-11-13-28-53-image.png)

比较：

1. 直接映射是最简单的地址映射方式，它的硬件简单，成本低，地址变换速度快，而且不涉及替换算法问题。**但Cache的存储空间得不到充分利用**

2. 全相联映射：Cache比较电路的设计和实现比较困难，这种方式只适合于**小容量**Cache采用

3. 组相联映射，用的比较普遍

## 二、替换算法

1. 先进先出(FIFO)算法，不太符合实际的使用

2. 近期最少使用（LRU)算法，基本上用的就是这个算法
