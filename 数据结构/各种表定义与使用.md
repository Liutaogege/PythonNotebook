**向量的定义与使用**

```c
#include <stdio.h>

const MaxSize=100;
typedef int datatype;  //说明结构体的数据类型要以情况而定

typedef struct {
    datatype V[MaxSize];
    int n;  // 表长
} SeqList;

SeqList L;
int i, j;
datatype x;

void Insert(SeqList L, int i, datatype x) {
    int j;
    if (i<0 || (i>L.n)) {
        Error("position error");
    }
    if (L.n >= MaxSize) {
        Error("overflow");
    }
    for (j=L.n-1; j>=i; j--) 
        L.V[j+1]=L.V[j];
    L.V[i]=x;
    L.n++;
}

void Delete(SeqList L, int i, datatype x) {
    int j;
    if (i<0 || (i>L.n)) {
        Error("position error");
    }
    if (L.n < 0) {
        Error("overflow");
    }
    for (j=i; j<L.n-1; j++) 
        L.V[j]=L.V[j+1];
    L.V[L.n-1]==NULL;
    L.n--;
}
```



**顺序栈的定义与使用**

```c
#include <stdio.h>
# define MaxSize 100

typedef char datatype;

typedef struct {
    datatype S[MaxSize];
    int top;  //栈顶指针，实际上就是数组的下标
} SeqStack;

SeqStack ST;
datatype x;

// 栈的推入操作
void push (SeqStack ST, datatype x) {
    if (ST.top >= MaxSize -1) {
        printf("overflow");
    }else {
        ST.S[++ST.top] = x;
    }
}

// 栈的推出操作
void pop(SeqStack ST, datatype x) {
    if (ST.top==-1) {
        printf("underflow");
    }else {
        x=ST.S[ST.top--]; //x表示被推出的值，然后ST.top要减一，这句话相当于x=ST.S[ST.top];ST.top--;
    }
}

// 读栈顶元素
datatype GetTop(SeqStack ST) {
    if (ST.top==-1) {
        printf("error");//为空栈
    }else {
        return ST.S[ST.top];
    }
}

// 清空栈
void ClearStack(SeqStack ST) {
    ST.top=-1;//把指针不指向任何元素
}

// 判断栈是否为空
int StackEmpty(SeqStack ST) {
    if (ST.top==-1)
        return 1;
    else return 0;
}
```



**顺序队列的定义与使用**

```c
#include <stdio.h>
# define MaxSize 100

typedef char datatype;

typedef struct {
    datatype Q[MaxSize];
    int front, rear;  // 队头和队尾指针，实际上就是数组下标
} SeqQueue;
SeqQueue QU;
datatype x;

// 队列的插入
void EnQueue(SeqQueue QU, datatype x) {
    // 如果超出最大队列空间，
    if (QU.front == (QU.rear + 1) % MaxSize) {
        printf("overflow");
    }else {
        QU.Q[QU.rear] = x;
        QU.rear = (QU.rear+1) % MaxSize;
    }
}

// 队列的删除
void DeQueue(SeqQueue QU, datatype x) {
    if (QU.front == QU.rear) {
        printf("underflow");
    }else {
        x = QU.Q[QU.front];
        QU.front = (QU.front + 1) % MaxSize;
    }
}

// 读队头元素
datatype GetFront(SeqQueue QU, datatype x) {
    if (QU.front == QU.rear) {
        printf("error");
    }
    else {
        x = QU.Q[QU.front];
    }
    return x;
}

// 清空队列
void ClearQueue(SeqQueue QU) {
    QU.front = QU.rear = 0;
}

// 判断队列是否为空
int QueueEmpty(SeqQueue QU) {
    if (QU.rear==QU.front) {
        return 1;
    }else return 0;
}

```

