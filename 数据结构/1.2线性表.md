# 线性表

一种典型的线性结构

数据的逻辑结构可以描述为一个二元组：

Data_Structure=(D,R)

其中D是数据元素的有穷集合，R是D上关系的有穷集合。



线性表的D,R表示如下:

D = {a0, a1, ..., an}

R = {r}

r = { **<ai-1, ai>**  |  ai ∈D, 1<=i<=n-1}

由以上的关系，线性表可以排成一个线性序列，a0,a1...

记为L=(a0,a1,..an-1)

> 注：数组元素的别名

在向量，数组中，叫作元素

在图中，叫作顶点

在文件中，叫作记录

更为通用的名字：结点



## 向量

向量是具有相同数据类型的数据元素组成的线性表，元素的地址是他在表中位置的线性函数（LOC(ai)=LOC(a0)+i*c)。

因此存取元素的时间复杂度为O(1)，但是插入、删除的元素复杂度为O(n)。

如果线性表的数据元素不是同一类型，每个元素所占的存储空间就不可能相同，仍采用顺序存储的方法就不能快速存取任一元素。为了提高速度，可以采用索引的方法。



**向量的定义与操作**

```c
#include <stdio.h>

const MaxSize=100;
typedef int datatype;  //说明结构体的数据类型要以情况而定

typedef struct {
    datatype V[MaxSize];
    int n;  // 表长
} SeqList;

SeqList L;
int i, j;
datatype x;

void Insert(SeqList L, int i, datatype x) {
    int j;
    if (i<0 || (i>L.n)) {
        Error("position error");
    }
    if (L.n >= MaxSize) {
        Error("overflow");
    }
    for (j=L.n-1; j>=i; j--) 
        L.V[j+1]=L.V[j];
    L.V[i]=x;
    L.n++;
}

void Delete(SeqList L, int i, datatype x) {
    int j;
    if (i<0 || (i>L.n)) {
        Error("position error");
    }
    if (L.n < 0) {
        Error("overflow");
    }
    for (j=i; j<L.n-1; j++) 
        L.V[j]=L.V[j+1];
    L.V[L.n-1]==NULL;
    L.n--;
}

```





## 栈

==先进后出(FILO)==

是一种运算受限的线性表，只能在同一端进行插入和删除运算，**允许运算的一端称为栈顶，另一端称为栈底**，表中没有元素的称为空栈。

又称为堆栈，下推表，FILO表

用顺序方式存储的栈称为顺序栈，链接方式存储的称为链栈。

为了避免栈的溢出，可以给两个栈分配共同的连续存储区域，入口相对。

![image-20210917192030153](/Users/jared/Library/Application Support/typora-user-images/image-20210917192030153.png)

**顺序栈的定义与操作****

```c
#include <stdio.h>
# define MaxSize 100

typedef char datatype;

typedef struct {
    datatype S[MaxSize];
    int top;  //栈顶指针，实际上就是数组的下标
} SeqStack;

SeqStack ST;
datatype x;

// 栈的推入操作
void push (SeqStack ST, datatype x) {
    if (ST.top >= MaxSize -1) {
        printf("overflow");
    }else {
        ST.S[++ST.top] = x;
    }
}

// 栈的推出操作
void pop(SeqStack ST, datatype x) {
    if (ST.top==-1) {
        printf("underflow");
    }else {
        x=ST.S[ST.top--]; //x表示被推出的值，然后ST.top要减一，这句话相当于x=ST.S[ST.top];ST.top--;
    }
}

// 读栈顶元素
datatype GetTop(SeqStack ST) {
    if (ST.top==-1) {
        printf("error");//为空栈
    }else {
        return ST.S[ST.top];
    }
}

// 清空栈
void ClearStack(SeqStack ST) {
    ST.top=-1;//把指针不指向任何元素
}

// 判断栈是否为空
int StackEmpty(SeqStack ST) {
    if (ST.top==-1)
        return 1;
    else return 0;
}
```



### 递归

若一个对象部分地包含它自己，或用它自己定义自己，则称这个对象是递归（定义）的；若一个过程直接地或间接的调用他自己，则称这个过程是递归的过程。

==递归必须要有递归出口，即必须要有结束条件==

符合递归定义的有：链表，斐波那契数列，阿克曼函数，树，二叉树，广义表等

符合递归过程的有：汉诺塔

递归写起来很方便，但是耗时间且耗空间

**递归为啥耗空间：递归调用时，会在内存的动态区中开辟一个存储区域，每次递归调用时，就将递归工作栈的指针下推，即每调用一次，就会占用一个存储空间，调用n次就要占用n个**



==背包问题：一个背包的可装重量为s，现在有n件物品，是否可以从n件物品中取出若干件恰好装满这个背包==

```python
global a
a = list(range(10))
def backage_solve(s, n):
    if s == 0:
        return True
    if s < 0 or (n < 1 and s > 0):
        return False
    if backage_solve(s-a[n], n -1):
        print(a[n])
        return True
    else:
        return backage_solve(s, n-1)
    
backage_solve(10, 9)
```



# 队列

也是一种运算受限的线性表，只允许在表的一端进行插入，在表的另一端进行删除。允许插入的一端称为队尾，允许删除的一端称为队头。

先进先出（FIFO).

插入操作称为入队，删除操作称为出队。**入队只能从队尾进入，出队只能从队头删除，不能插队**。和排队一个道理

队列的存储方式也有两种，顺序存储和链接存储。顺序队列，链队。

和栈相似，都需要用连续的存储空间来存放队列中的元素，除此之外，还需要设置两个指针front和rear分别指示队头元素和队尾元素的位置。它们的初始值为0，front指针始终指向队头元素，rear指向队尾元素的下一个位置，时刻准备迎接新队员的到来。

![image-20210923204157174](/Users/jared/Library/Application Support/typora-user-images/image-20210923204157174.png)

==注意==

正常情况下，front和rear的取值范围是0-Maxsize-1。

当出队时（即删除操作），会返回删除元素，front指针加1，随着插入和删除操作的进行，此时front的指针并不会归0，而如果持续插入操作的话直至rear=Maxsize-1，此时就会溢出，称为假溢出。当front为0时，即为真溢出。

循环队列诞生来解决这个假溢出问题，当rear或front达到Maxsize-1时，就采用求余法计算下一指针指向的位置（余数=位置%Maxsize)，当余数=1时，指针就重新指向起始位置0。所以有可能会出现rear位置在front前面的情况，以及存满以后front和rear指针位置重合的情况。因此循环队列要求最多只能存放Maxsize-1个元素。

**队列的定义**

```c
#include <stdio.h>
# define MaxSize 100

typedef char datatype;

typedef struct {
    datatype Q[MaxSize];
    int front, rear;  // 队头和队尾指针，实际上就是数组下标
} SeqQueue;
SeqQueue QU;
datatype x;

```

