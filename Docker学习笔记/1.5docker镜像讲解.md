# Docker镜像讲解

### 镜像是什么

镜像是一种轻量级，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含某个软件所需要的所有内容，包括代码、运行时、库、环境变量和配置文件

所有的应用直接打包docker镜像，就不用配置环境，直接跑起来

如何得到镜像：

	- 仓库下载
	- 拷贝
	- 自己制作



### Docker镜像加载原理

```
UnionFs(联合系统文件)
```

UnionFs（联合系统文件）：Union文件系统是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层一层的叠加，同时可以将不同的目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础，镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。

特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统就会包含所有底层的文件和目录



```
Docker镜像加载原理
```

docker的镜像实际上有一层一层的文件系统组成，这种层级的文件系统就是UnionFs

Bootfs(boot file system)主要包含Bootloader和kernel，BootLoader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核，当boot加载完成之后整个内核都在内存中了，此时内存的使用权已经由bootfs转交给内核，此时系统也会卸载bootfs

rootfs（root file system),在bootfs之上，包含的就是典型Linux系统中的/dev,/proc,/bin/etc,等标准目录和文件，rootfs就是各种不同的操作系统发行版，，比如Ubuntu，Centos

![image-20210822091827977](/Users/jared/Library/Application Support/typora-user-images/image-20210822091827977.png)

而Docker镜像之所以很小，是因为对于精简的os，rootfs可以很小，只需要包含最基本的命令，工具和程序库就可以，因为底层直接使用的是主机的kernel，自己只需要提供rootfs就可以了，由此可见对于不同的linux发行版，bootfs基本上是一致的，rootfs会有差别，因此不同的发行版可以共用一个bootfs。



### 分层理解

```
分层的镜像
```

![image-20210822092744964](/Users/jared/Library/Application Support/typora-user-images/image-20210822092744964.png)

观察镜像的下载是一层一层进行的，

最大的好处应该就是资源共享，节省内存。

查看镜像分层可以通过命令：docker inpect redis

#### **理解**

所有的Docker镜像都起始于衣蛾基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上创建新的镜像层。比如：基于Ubuntu新建一个镜像，这是镜像的第一层，如果在该镜像中添加Python包，就会在基础镜像层之上创建第二个镜像层，如果继续添加一个安全补丁，就会创建第三个镜像层。

该镜像已经包含当前三个镜像层，如图所示：

![image-20210822093348944](/Users/jared/Library/Application Support/typora-user-images/image-20210822093348944.png)

在添加额外的镜像层的同时，镜像始终保持当前所有镜像的组合。即镜像中可以包含多个镜像，而每个镜像都各自保持着自己的组合。比如下图：

![image-20210822093712211](/Users/jared/Library/Application Support/typora-user-images/image-20210822093712211.png)

上图中的镜像和之前图中的镜像有区别，主要是为了便于展示文件

下图中展示了一个稍微复杂的三层镜像，在外部看起来整个镜像只有6个文件，这是因为最上层中的文件7是文件5的一个更新版本

![image-20210822093944080](/Users/jared/Library/Application Support/typora-user-images/image-20210822093944080.png)

这种情况下，上层镜像中的文件覆盖了底层镜像层中的文件，这样就使得文件的更新作为一个新镜像层添加到镜像当中

docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统。

linux上可用的存储引擎有AUFS,Overlay2，DeviceMapper，Btrfs以及ZFS，每种存储引擎都是基于Linux中对应的文件系统或者块设置技术，并且每种存储引擎都有其独有的性能特点。

Docker在Windows上仅仅支持windowsfilter一种存储引擎，该引擎基于NTFS文件系统上实现了分层和Cow，下图展示了系统显示相同的三层镜像，所有镜像层堆叠并合并，对外提供统一的视图。

![image-20210822094421844](/Users/jared/Library/Application Support/typora-user-images/image-20210822094421844.png)

```
特点：
```

Docker镜像都是只读，当容器启动时，一个新的可写层被加载道镜像的顶部，这一层就是我们常说的容器层，容器之下都叫镜像层

![image-20210822102706869](/Users/jared/Library/Application Support/typora-user-images/image-20210822102706869.png)

### 提交自己的镜像：commit

docker commit    提交容器成为一个新的副本

```
docker commit -m="提交的描述信息" -a="作者" 容器id 目标镜像名,[TAG]
```

```
如果想要保存一个容器的状态，就可以通过commit来提交，获得一个新的镜像
```

